# Music2.0
We decided to use Project 4 to continue our investigation into music using machine learning. We wanted to determine if a song was danceable or not using various other aspects of a song like tempo, energy, loudness etc. Using Machine Learning, we could train a machine to sort songs as 0 (not Danacble) and 1 (Dancable)

 In order to complete this, we did the following tasks:

# Yalena (Data Collection and Cleaning):
As the Data Engineer, I was responsible for preparing and structuring the data for analysis and model building. My primary focus was to prepare and structure the dataset for subsequent analysis and modeling tasks. I began by importing a sample of 500 rows from the dataset using the pandas library. This step was for working with a manageable subset of the data to ensure efficient processing. Next, I cleaned the dataset by removing irrelevant columns that did not contribute to the analysis, such as 'Unnamed: 0', 'track_id', 'artists', 'album_name', 'track_name', and 'mode'. To address data quality issues, I handled missing values by dropping rows with any missing entries and removed duplicate rows to ensure data integrity.

# Emilie ( Data Analytics): 
I took the cleaned Data Yalena created and split the data into train and test data using split_test_split from sklearn. Using this data I used a combination of features to use as the x variables to determine variability. I played with a mix of the following features: 'duration’, 'popularity', 'energy', 'loudness', 'speechiness', 'acousticness', 'instrumentalness', 'liveness', 'valence', 'tempo', 'explicit'  to achieve a moderately accurate learning model. I attempted to create a Linear Regression model to determine the dancability of a song from a scale of 0 to 1 but the model predictions proved to be very inaccurate. I then attempted to use a sorting method of Logistic Regression and Random Forest model to sort dancability into 0 or 1 and this proved more promising. 

# Hannah (Machine Learning):  
I took the initial data exploration that Emilie had done and went back to our data source to do a bit of a deeper dive into the provided data. I found that the danceability column in our data set was determined by,  “...how suitable a track is for dancing based on a combination of musical elements including tempo, rhythm stability, beat strength, and overall regularity. A value of 0.0 is least danceable and 1.0 is most danceable”. Our data set only had an additional column of tempo from those elements, but the keggle page our data set came from included a small line graph for each column. So I compared the line graphs of tempo and danceability, which were very similar, to the other graphs and pulled columns that were also similar. This gave me the x- features of energy, loudness, valence, and tempo. I ran each model with this X- feature set with a y- feature of the danceability binary column. The results were very similar to Emilie’s finding so we determined that the random forest model would be the best to move forward with optimizing.

# Julia (Optimization): 
I was responsible for optimizing the logistic regression and random forest models using GridSearchCV and RandomSearchCV to identify the most accurate model. Additionally, I handled the analysis of the ROC curve and the confusion matrix to evaluate and compare the models' performance

# Nicole (Visualizations): I initially created a correlation matrix to determine if danceability correlated with any of the features included in the dataset using seaborn. I also created an interactive scatter plot using Plotly (applying PCA to reduce dimensions) to visualize actual danceability vs predicted danceability for each song in the dataset. As an additional visualization, I created a kernel density estimation plot visualization to determine which feature had the highest positive correlation to danceability based on our Random Forest Model.
